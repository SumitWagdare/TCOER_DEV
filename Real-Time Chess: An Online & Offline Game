<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game (Online & Offline)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 640px;
            max-height: 640px;
            border: 2px solid #374151; /* gray-700 */
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .square .piece {
            font-size: clamp(20px, 8vw, 60px);
            cursor: pointer;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }

        .selected {
            background-color: #6b90a3 !important;
        }
        .valid-move {
            background-color: rgba(20, 80, 40, 0.5) !important;
            border-radius: 50%;
        }
        .check {
            background: radial-gradient(circle, rgba(255,0,0,0.7) 0%, rgba(255,0,0,0) 70%);
        }
        .last-move {
            background-color: rgba(255, 255, 0, 0.4);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal-content {
            background: #2d3748; /* gray-800 */
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .promotion-piece {
            font-size: 3rem;
            cursor: pointer;
            margin: 0 0.5rem;
            transition: transform 0.2s;
        }
        .promotion-piece:hover {
            transform: scale(1.2);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Main Game UI -->
    <div id="game-container" class="hidden w-full max-w-7xl mx-auto flex flex-col lg:flex-row items-center lg:items-start justify-center gap-8">
        <div class="flex flex-col items-center">
            <div id="info-top" class="mb-2 h-10 text-lg font-semibold"></div>
            <div id="board-container" class="relative">
                <div id="chess-board" class="chess-board shadow-2xl"></div>
            </div>
            <div id="info-bottom" class="mt-2 h-10 text-lg font-semibold"></div>
        </div>
        <div id="game-info" class="w-full lg:w-80 bg-gray-800 p-4 rounded-lg shadow-xl flex flex-col gap-4">
            <h2 class="text-2xl font-bold text-center border-b border-gray-600 pb-2">Game Info</h2>
            <div>
                <strong class="text-blue-400">Status:</strong>
                <span id="game-status">Waiting for game to start...</span>
            </div>
             <div>
                <strong class="text-blue-400">Turn:</strong>
                <span id="turn-indicator">White</span>
            </div>
            <div id="online-info" class="hidden flex flex-col gap-2">
                <div><strong class="text-blue-400">Your User ID:</strong></div>
                <div class="flex items-center gap-2">
                    <input type="text" id="user-id" readonly class="w-full bg-gray-700 p-2 rounded border border-gray-600 focus:outline-none">
                    <button id="copy-user-id" class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded">Copy</button>
                </div>
                 <div><strong class="text-blue-400">Game ID:</strong></div>
                 <div class="flex items-center gap-2">
                    <input type="text" id="game-id-display" readonly class="w-full bg-gray-700 p-2 rounded border border-gray-600 focus:outline-none">
                    <button id="copy-game-id" class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded">Copy</button>
                </div>
            </div>
            <button id="reset-game" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors">
                New Game
            </button>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu" class="text-center">
        <h1 class="text-6xl font-bold mb-8">Chess Game</h1>
        <div class="space-y-4">
            <button id="play-offline" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-64">Play Offline</button>
            <button id="play-online" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-64">Play Online</button>
        </div>
    </div>

    <!-- Online Menu -->
    <div id="online-menu" class="hidden text-center">
        <h2 class="text-4xl font-bold mb-6">Online Lobby</h2>
        <div class="space-y-4">
            <button id="create-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-72">Create New Game</button>
            <div class="flex flex-col items-center gap-2">
                <input type="text" id="join-game-id" placeholder="Enter Game ID to Join" class="bg-gray-700 text-white text-center p-3 rounded-lg w-72 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="join-game" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-72">Join Game</button>
            </div>
            <button id="back-to-main" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Back</button>
        </div>
    </div>
    
    <!-- Promotion Modal -->
    <div id="promotion-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-bold mb-4">Promote Pawn to:</h3>
            <div id="promotion-choices"></div>
        </div>
    </div>

    <footer class="text-center text-gray-500 text-sm absolute bottom-4">
        <p>&copy; 2025 sumit tcoer_dev. All rights reserved.</p>
    </footer>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM ELEMENTS ---
        const boardElement = document.getElementById('chess-board');
        const gameContainer = document.getElementById('game-container');
        const mainMenu = document.getElementById('main-menu');
        const onlineMenu = document.getElementById('online-menu');
        const gameStatus = document.getElementById('game-status');
        const turnIndicator = document.getElementById('turn-indicator');
        const onlineInfo = document.getElementById('online-info');
        const promotionModal = document.getElementById('promotion-modal');
        const promotionChoices = document.getElementById('promotion-choices');

        // --- FIREBASE SETUP ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-chess-app';
        let firebaseConfig;
        try {
            firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "DEMO", authDomain: "DEMO", projectId: "DEMO" };
        } catch (e) {
            console.error("Firebase config parsing error:", e);
            firebaseConfig = { apiKey: "DEMO", authDomain: "DEMO", projectId: "DEMO" };
        }

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- GAME STATE ---
        let board = [];
        let currentPlayer = 'w';
        let selectedPiece = null;
        let validMoves = [];
        let gameMode = 'offline'; // 'offline' or 'online'
        let onlineGameId = null;
        let onlinePlayerColor = null;
        let unsubscribeGameListener = null;
        let kingInCheck = null;
        let lastMove = null;
        let userId = null;

        // --- PIECE DEFINITIONS ---
        const pieces = {
            'p': { type: 'pawn', color: 'b', svg: '&#9823;' }, 'r': { type: 'rook', color: 'b', svg: '&#9820;' },
            'n': { type: 'knight', color: 'b', svg: '&#9822;' }, 'b': { type: 'bishop', color: 'b', svg: '&#9821;' },
            'q': { type: 'queen', color: 'b', svg: '&#9819;' }, 'k': { type: 'king', color: 'b', svg: '&#9818;' },
            'P': { type: 'pawn', color: 'w', svg: '&#9817;' }, 'R': { type: 'rook', color: 'w', svg: '&#9814;' },
            'N': { type: 'knight', color: 'w', svg: '&#9816;' }, 'B': { type: 'bishop', color: 'w', svg: '&#9815;' },
            'Q': { type: 'queen', color: 'w', svg: '&#9813;' }, 'K': { type: 'king', color: 'w', svg: '&#9812;' },
        };
        
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
        ];

        // --- RENDER & UI ---
        
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const pieceChar = board[row][col];
                    if (pieceChar) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = 'piece';
                        pieceElement.innerHTML = pieces[pieceChar].svg;
                        square.appendChild(pieceElement);
                    }

                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }

                    if (kingInCheck && board[row][col]?.toLowerCase() === 'k' && pieces[board[row][col]].color === kingInCheck) {
                        square.classList.add('check');
                    }
                    
                    if(lastMove && ((lastMove.from.row === row && lastMove.from.col === col) || (lastMove.to.row === row && lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }
                    
                    boardElement.appendChild(square);
                }
            }
            // Draw valid moves after pieces
            validMoves.forEach(({ row, col }) => {
                const square = boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
                const moveIndicator = document.createElement('div');
                moveIndicator.className = 'valid-move';
                square.appendChild(moveIndicator);
            });
        }
        
        function updateUI() {
            turnIndicator.textContent = currentPlayer === 'w' ? 'White' : 'Black';
            const colorClass = currentPlayer === 'w' ? 'text-blue-300' : 'text-red-300';
            turnIndicator.className = `font-bold ${colorClass}`;
            
            // Flip board for black player in online mode
            if (gameMode === 'online' && onlinePlayerColor === 'b') {
                boardElement.style.transform = 'rotate(180deg)';
                boardElement.querySelectorAll('.piece').forEach(p => p.style.transform = 'rotate(180deg)');
            } else {
                 boardElement.style.transform = 'rotate(0deg)';
                boardElement.querySelectorAll('.piece').forEach(p => p.style.transform = 'rotate(0deg)');
            }
        }
        
        // --- GAME LOGIC ---

        function getPiece(row, col, boardState = board) {
            if (row < 0 || row >= 8 || col < 0 || col >= 8) return null;
            const pieceChar = boardState[row][col];
            return pieceChar ? pieces[pieceChar] : null;
        }

        function getRawMoves(piece, row, col, boardState) {
            const moves = [];
            const { type, color } = piece;
            const dir = color === 'w' ? -1 : 1;
            
            const addSlidingMoves = (directions) => {
                directions.forEach(([dr, dc]) => {
                    let r = row + dr, c = col + dc;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const target = getPiece(r, c, boardState);
                        if (!target) {
                            moves.push({ row: r, col: c });
                        } else {
                            if (target.color !== color) moves.push({ row: r, col: c });
                            break;
                        }
                        r += dr; c += dc;
                    }
                });
            };

            switch (type) {
                case 'pawn':
                    if (!getPiece(row + dir, col, boardState)) {
                        moves.push({ row: row + dir, col: col });
                        const startRow = color === 'w' ? 6 : 1;
                        if (row === startRow && !getPiece(row + 2 * dir, col, boardState)) {
                            moves.push({ row: row + 2 * dir, col: col });
                        }
                    }
                    [-1, 1].forEach(dc => {
                        const target = getPiece(row + dir, col + dc, boardState);
                        if (target && target.color !== color) {
                            moves.push({ row: row + dir, col: col + dc });
                        }
                    });
                    break;
                case 'rook':
                    addSlidingMoves([[0, 1], [0, -1], [1, 0], [-1, 0]]);
                    break;
                case 'knight':
                    [[2,1], [2,-1], [-2,1], [-2,-1], [1,2], [1,-2], [-1,2], [-1,-2]].forEach(([dr, dc]) => {
                        const r = row + dr, c = col + dc;
                        const target = getPiece(r, c, boardState);
                        if (r >= 0 && r < 8 && c >= 0 && c < 8 && (!target || target.color !== color)) {
                           moves.push({ row: r, col: c });
                        }
                    });
                    break;
                case 'bishop':
                    addSlidingMoves([[1, 1], [1, -1], [-1, 1], [-1, -1]]);
                    break;
                case 'queen':
                    addSlidingMoves([[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
                    break;
                case 'king':
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const r = row + dr, c = col + dc;
                            const target = getPiece(r,c, boardState);
                            if (r >= 0 && r < 8 && c >= 0 && c < 8 && (!target || target.color !== color)) {
                                moves.push({ row: r, col: c });
                            }
                        }
                    }
                    break;
            }
            return moves;
        }

        function getValidMoves(piece, row, col, currentBoard) {
            const rawMoves = getRawMoves(piece, row, col, currentBoard);
            const { color } = piece;
            return rawMoves.filter(move => !moveLeavesKingInCheck(row, col, move.row, move.col, color));
        }
        
        function findKing(color, currentBoard) {
            const kingChar = color === 'w' ? 'K' : 'k';
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    if (currentBoard[r][c] === kingChar) return {row: r, col: c};
                }
            }
            return null;
        }
        
        function isSquareAttacked(row, col, attackerColor, currentBoard) {
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const pieceChar = currentBoard[r][c];
                    if (pieceChar && pieces[pieceChar].color === attackerColor) {
                        const piece = pieces[pieceChar];
                        if (piece.type === 'pawn') {
                            const dir = attackerColor === 'w' ? -1 : 1;
                            if ((r + dir === row && c + 1 === col) || (r + dir === row && c - 1 === col)) {
                                return true;
                            }
                        } else {
                            const moves = getRawMoves(piece, r, c, currentBoard);
                            if (moves.some(m => m.row === row && m.col === col)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function isKingInCheck(color, currentBoard) {
            const kingPos = findKing(color, currentBoard);
            if (!kingPos) return false;
            const opponentColor = color === 'w' ? 'b' : 'w';
            return isSquareAttacked(kingPos.row, kingPos.col, opponentColor, currentBoard);
        }

        function moveLeavesKingInCheck(fromRow, fromCol, toRow, toCol, color) {
             const tempBoard = JSON.parse(JSON.stringify(board));
             tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
             tempBoard[fromRow][fromCol] = null;
             return isKingInCheck(color, tempBoard);
        }
        
        function hasAnyValidMoves(color) {
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const pieceChar = board[r][c];
                    if(pieceChar && pieces[pieceChar].color === color) {
                        if(getValidMoves(pieces[pieceChar], r, c, board).length > 0) return true;
                    }
                }
            }
            return false;
        }

        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const pieceChar = board[fromRow][fromCol];
            const piece = pieces[pieceChar];

            // Pawn Promotion
            if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                const newPieceChar = await handlePawnPromotion(piece.color);
                board[toRow][toCol] = newPieceChar;
            } else {
                 board[toRow][toCol] = pieceChar;
            }
            
            board[fromRow][fromCol] = null;
            
            selectedPiece = null;
            validMoves = [];
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            
            const opponentColor = currentPlayer;
            const inCheck = isKingInCheck(opponentColor, board);
            kingInCheck = inCheck ? opponentColor : null;
            
            if (inCheck) {
                if (!hasAnyValidMoves(opponentColor)) {
                    gameStatus.textContent = `Checkmate! ${currentPlayer === 'w' ? 'Black' : 'White'} wins.`;
                    turnIndicator.textContent = "-";
                } else {
                    gameStatus.textContent = `${opponentColor === 'w' ? 'White' : 'Black'} is in check.`;
                }
            } else {
                 if (!hasAnyValidMoves(opponentColor)) {
                    gameStatus.textContent = "Stalemate! It's a draw.";
                    turnIndicator.textContent = "-";
                } else {
                    gameStatus.textContent = "Game in progress";
                }
            }

            if (gameMode === 'online') {
                await updateFirestoreGame();
            } else {
                renderBoard();
                updateUI();
            }
        }
        
        function handlePawnPromotion(color) {
            return new Promise(resolve => {
                promotionModal.style.display = 'flex';
                const promotionOptions = color === 'w' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
                promotionChoices.innerHTML = '';
                promotionOptions.forEach(pChar => {
                    const pieceEl = document.createElement('span');
                    pieceEl.className = 'promotion-piece';
                    pieceEl.innerHTML = pieces[pChar].svg;
                    pieceEl.onclick = () => {
                        promotionModal.style.display = 'none';
                        resolve(pChar);
                    };
                    promotionChoices.appendChild(pieceEl);
                });
            });
        }
        
        async function handleSquareClick(row, col) {
            // Online mode: only allow moves for your color on your turn
            if (gameMode === 'online' && currentPlayer !== onlinePlayerColor) {
                return;
            }

            const piece = getPiece(row, col);
            if (selectedPiece) {
                const isValid = validMoves.some(move => move.row === row && move.col === col);
                if (isValid) {
                    await makeMove(selectedPiece.row, selectedPiece.col, row, col);
                } else {
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard(); // Deselect
                }
            } else if (piece && piece.color === currentPlayer) {
                selectedPiece = { row, col, ...piece };
                validMoves = getValidMoves(piece, row, col, board);
                renderBoard();
            }
        }
        
        function initGame() {
            board = JSON.parse(JSON.stringify(initialBoard));
            currentPlayer = 'w';
            selectedPiece = null;
            validMoves = [];
            kingInCheck = null;
            lastMove = null;
            gameStatus.textContent = "Game started. White's turn.";
            renderBoard();
            updateUI();
        }

        // --- ONLINE FUNCTIONALITY ---
        
        async function createOnlineGame() {
            const gameRef = doc(db, `artifacts/${appId}/public/data/chess`, crypto.randomUUID());
            onlineGameId = gameRef.id;
            onlinePlayerColor = 'w';

            const initialGameState = {
                board: JSON.stringify(initialBoard),
                currentPlayer: 'w',
                players: { [userId]: 'w' },
                status: 'waiting',
                lastMove: null
            };
            await setDoc(gameRef, initialGameState);
            startGameOnline(onlineGameId);
            document.getElementById('game-id-display').value = onlineGameId;
            document.getElementById('user-id').value = userId;
        }
        
        async function joinOnlineGame() {
            const gameId = document.getElementById('join-game-id').value.trim();
            if (!gameId) {
                alert("Please enter a Game ID.");
                return;
            }
            const gameRef = doc(db, `artifacts/${appId}/public/data/chess`, gameId);
            const gameSnap = await getDoc(gameRef);

            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                if (Object.keys(gameData.players).length >= 2) {
                    alert("This game is already full.");
                    return;
                }
                onlinePlayerColor = 'b';
                gameData.players[userId] = 'b';
                gameData.status = 'active';
                await updateDoc(gameRef, { players: gameData.players, status: gameData.status });
                startGameOnline(gameId);
            } else {
                alert("Game not found. Please check the ID.");
            }
        }

        function startGameOnline(gameId) {
            mainMenu.classList.add('hidden');
            onlineMenu.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            onlineInfo.classList.remove('hidden');
            gameMode = 'online';
            onlineGameId = gameId;

            if (unsubscribeGameListener) unsubscribeGameListener();
            
            unsubscribeGameListener = onSnapshot(doc(db, `artifacts/${appId}/public/data/chess`, gameId), (doc) => {
                if (!doc.exists()) return;
                const gameData = doc.data();
                board = JSON.parse(gameData.board);
                currentPlayer = gameData.currentPlayer;
                lastMove = gameData.lastMove ? JSON.parse(gameData.lastMove) : null;
                
                const inCheck = isKingInCheck(currentPlayer, board);
                kingInCheck = inCheck ? currentPlayer : null;

                renderBoard();
                updateUI();
                
                gameStatus.textContent = gameData.status === 'waiting' ? `Waiting for opponent... Game ID: ${gameId}` : `Game in progress. Your color: ${onlinePlayerColor === 'w' ? 'White' : 'Black'}`;
            });
        }
        
        async function updateFirestoreGame() {
            if (!onlineGameId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/chess`, onlineGameId);
            await updateDoc(gameRef, {
                board: JSON.stringify(board),
                currentPlayer: currentPlayer,
                lastMove: JSON.stringify(lastMove)
            });
        }
        
        // --- EVENT LISTENERS ---
        boardElement.addEventListener('click', e => {
            const square = e.target.closest('.square');
            if (square) {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                handleSquareClick(row, col);
            }
        });
        
        document.getElementById('play-offline').addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            onlineInfo.classList.add('hidden');
            gameMode = 'offline';
            initGame();
        });
        
        document.getElementById('play-online').addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            onlineMenu.classList.remove('hidden');
        });

        document.getElementById('create-game').addEventListener('click', createOnlineGame);
        document.getElementById('join-game').addEventListener('click', joinOnlineGame);
        document.getElementById('back-to-main').addEventListener('click', () => {
            onlineMenu.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });
        
        document.getElementById('reset-game').addEventListener('click', () => {
            if (unsubscribeGameListener) unsubscribeGameListener();
            onlineGameId = null;
            onlinePlayerColor = null;
            gameContainer.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });
        
        document.getElementById('copy-user-id').addEventListener('click', () => {
            navigator.clipboard.writeText(userId).then(() => alert('User ID copied!'));
        });

        document.getElementById('copy-game-id').addEventListener('click', () => {
             const gameId = document.getElementById('game-id-display').value;
            navigator.clipboard.writeText(gameId).then(() => alert('Game ID copied!'));
        });
        
        // --- INITIALIZATION ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                document.getElementById('user-id').value = userId;
            } else {
                 try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Authentication error:", error);
                }
            }
        });

    </script>
</body>
</html>


