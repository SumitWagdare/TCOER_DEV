<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wavacity Pro - Audio Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #1f2937;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        canvas {
            cursor: text;
        }
        .loader {
            border: 5px solid #374151; /* gray-700 */
            border-top: 5px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex flex-col h-screen overflow-hidden">

    <!-- Loading Modal -->
    <div id="loadingModal" class="fixed inset-0 bg-black bg-opacity-70 flex-col items-center justify-center z-50 hidden">
        <div class="loader"></div>
        <p id="loadingText" class="mt-4 text-lg">Processing Audio...</p>
    </div>

    <!-- Header / Toolbar -->
    <header class="bg-gray-900 shadow-md p-2 flex items-center space-x-2 flex-wrap z-10">
        <div class="flex items-center space-x-2 mr-4">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
            <h1 class="text-xl font-bold">Wavacity Pro</h1>
        </div>
        
        <label for="file-upload" class="tooltip cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md inline-flex items-center transition-colors">
            <i data-lucide="folder-open" class="w-5 h-5 mr-2"></i>
            Open File
            <span class="tooltiptext">Load Audio</span>
        </label>
        <input id="file-upload" type="file" accept="audio/*" class="hidden"/>

        <!-- Playback Controls -->
        <div class="flex items-center bg-gray-800 rounded-md p-1 space-x-1">
             <button id="btn-play" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="play" class="w-5 h-5"></i>
                <span class="tooltiptext">Play/Pause (Space)</span>
            </button>
            <button id="btn-stop" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="stop-circle" class="w-5 h-5"></i>
                <span class="tooltiptext">Stop (Esc)</span>
            </button>
             <button id="btn-loop" class="tooltip p-2 rounded-md hover:bg-gray-700 data-[active=true]:bg-blue-600 data-[active=true]:text-white disabled:opacity-50 disabled:cursor-not-allowed" data-active="false" disabled>
                <i data-lucide="repeat" class="w-5 h-5"></i>
                <span class="tooltiptext">Toggle Loop (L)</span>
            </button>
        </div>

        <!-- Editing Controls -->
        <div class="flex items-center bg-gray-800 rounded-md p-1 space-x-1">
            <button id="btn-cut" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="scissors" class="w-5 h-5"></i>
                <span class="tooltiptext">Cut (Ctrl+X)</span>
            </button>
            <button id="btn-copy" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="copy" class="w-5 h-5"></i>
                <span class="tooltiptext">Copy (Ctrl+C)</span>
            </button>
            <button id="btn-paste" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="clipboard-paste" class="w-5 h-5"></i>
                <span class="tooltiptext">Paste (Ctrl+V)</span>
            </button>
             <button id="btn-delete" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="trash-2" class="w-5 h-5"></i>
                <span class="tooltiptext">Delete (Del)</span>
            </button>
            <button id="btn-trim" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="crop" class="w-5 h-5"></i>
                <span class="tooltiptext">Trim to Selection</span>
            </button>
        </div>

        <!-- Zoom Controls -->
        <div class="flex items-center bg-gray-800 rounded-md p-1 space-x-1">
            <button id="btn-zoom-in" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="zoom-in" class="w-5 h-5"></i>
                 <span class="tooltiptext">Zoom In (+)</span>
            </button>
            <button id="btn-zoom-out" class="tooltip p-2 rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i data-lucide="zoom-out" class="w-5 h-5"></i>
                <span class="tooltiptext">Zoom Out (-)</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col p-2 overflow-hidden">
        <div class="w-full h-full bg-gray-900 rounded-lg shadow-inner overflow-hidden flex flex-col relative" id="waveform-container">
            <canvas id="timeline-canvas" class="w-full bg-gray-700" height="30"></canvas>
            <div class="w-full flex-grow overflow-x-auto overflow-y-hidden">
                 <canvas id="waveform-canvas" class="h-full"></canvas>
            </div>
            <!-- Placeholder Text -->
            <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 text-2xl pointer-events-none">
                <p>Click "Open File" to start editing your audio</p>
            </div>
        </div>
    </main>
    
    <!-- Footer / Status Bar -->
    <footer class="bg-gray-900 text-gray-400 text-sm p-1 px-4 flex justify-between items-center z-10">
        <div>
            <span>Duration: <span id="duration" class="font-mono text-white">00:00.000</span></span> |
            <span>Sample Rate: <span id="sample-rate" class="font-mono text-white">N/A</span></span>
        </div>
        <div>
            <span>Selection Start: <span id="selection-start" class="font-mono text-white">00:00.000</span></span> |
            <span>End: <span id="selection-end" class="font-mono text-white">00:00.000</span></span> |
            <span>Length: <span id="selection-length" class="font-mono text-white">00:00.000</span></span>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();

            // DOM Elements
            const fileInput = document.getElementById('file-upload');
            const waveformCanvas = document.getElementById('waveform-canvas');
            const timelineCanvas = document.getElementById('timeline-canvas');
            const waveformContainer = document.getElementById('waveform-container');
            const placeholder = document.getElementById('placeholder');
            const loadingModal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            
            const playBtn = document.getElementById('btn-play');
            const stopBtn = document.getElementById('btn-stop');
            const loopBtn = document.getElementById('btn-loop');
            const zoomInBtn = document.getElementById('btn-zoom-in');
            const zoomOutBtn = document.getElementById('btn-zoom-out');

            const cutBtn = document.getElementById('btn-cut');
            const copyBtn = document.getElementById('btn-copy');
            const pasteBtn = document.getElementById('btn-paste');
            const deleteBtn = document.getElementById('btn-delete');
            const trimBtn = document.getElementById('btn-trim');

            const durationEl = document.getElementById('duration');
            const sampleRateEl = document.getElementById('sample-rate');
            const selectionStartEl = document.getElementById('selection-start');
            const selectionEndEl = document.getElementById('selection-end');
            const selectionLengthEl = document.getElementById('selection-length');

            const wfCtx = waveformCanvas.getContext('2d');
            const tlCtx = timelineCanvas.getContext('2d');

            // --- State Management ---
            let audioContext;
            let audioBuffer;
            let sourceNode;
            let clipboardBuffer;
            
            let zoom = 1; // 1 pixel per sample initially
            let isPlaying = false;
            let startTime = 0;
            let startOffset = 0;
            let animationFrameId;
            let isLooping = false;
            
            let selectionStartSample = null;
            let selectionEndSample = null;
            let isDragging = false;
            
            // --- UI Initialization ---
            const allButtons = document.querySelectorAll('button');
            const actionButtons = Array.from(allButtons).filter(btn => btn.id !== 'file-upload');

            function updateButtonStates() {
                const hasBuffer = !!audioBuffer;
                const hasSelection = selectionStartSample !== null && selectionEndSample !== null && selectionStartSample !== selectionEndSample;
                
                playBtn.disabled = !hasBuffer;
                stopBtn.disabled = !hasBuffer;
                loopBtn.disabled = !hasBuffer;
                zoomInBtn.disabled = !hasBuffer;
                zoomOutBtn.disabled = !hasBuffer;
                
                cutBtn.disabled = !hasSelection;
                copyBtn.disabled = !hasSelection;
                deleteBtn.disabled = !hasSelection;
                trimBtn.disabled = !hasSelection;
                
                pasteBtn.disabled = !clipboardBuffer;
            }
            updateButtonStates();

            // --- Audio Processing ---
            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                placeholder.style.display = 'none';
                loadingModal.style.display = 'flex';
                loadingText.textContent = `Loading ${file.name}...`;

                try {
                    initAudioContext();
                    const arrayBuffer = await file.arrayBuffer();
                    loadingText.textContent = 'Decoding audio data...';
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // Reset state for new file
                    resetState();
                    zoom = waveformContainer.clientWidth / audioBuffer.length;
                    updateButtonStates();
                    updateStatusBar();
                    draw();
                } catch (error) {
                    console.error('Error processing audio file:', error);
                    alert('Could not process the audio file. It may be corrupt or an unsupported format.');
                    placeholder.style.display = 'flex';
                } finally {
                    loadingModal.style.display = 'none';
                    fileInput.value = ''; // Reset input
                }
            });

            function resetState() {
                if(isPlaying) stopPlayback();
                startOffset = 0;
                selectionStartSample = null;
                selectionEndSample = null;
            }

            // --- Drawing ---
            function draw() {
                if (!audioBuffer) return;
                
                requestAnimationFrame(() => {
                    const canvasWidth = Math.max(waveformContainer.clientWidth, audioBuffer.length * zoom);
                    const canvasHeight = waveformContainer.clientHeight - timelineCanvas.height;

                    if (waveformCanvas.width !== canvasWidth || waveformCanvas.height !== canvasHeight) {
                        waveformCanvas.width = canvasWidth;
                        waveformCanvas.height = canvasHeight;
                    }
                    if (timelineCanvas.width !== canvasWidth) {
                        timelineCanvas.width = canvasWidth;
                    }
                    
                    drawWaveform();
                    drawTimeline();
                    drawSelection();
                    drawPlayhead();
                });
            }
            
            function drawWaveform() {
                const data = audioBuffer.getChannelData(0);
                const height = waveformCanvas.height;
                const halfHeight = height / 2;
                
                wfCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                wfCtx.strokeStyle = '#3b82f6'; // blue-500
                wfCtx.lineWidth = 1;
                
                wfCtx.beginPath();
                wfCtx.moveTo(0, halfHeight);

                const step = Math.ceil(1 / zoom);
                for (let i = 0; i < audioBuffer.length; i += step) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const sample = data[i + j];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                    const x = i * zoom;
                    wfCtx.moveTo(x, halfHeight + min * halfHeight);
                    wfCtx.lineTo(x, halfHeight + max * halfHeight);
                }
                wfCtx.stroke();
            }

            function drawTimeline() {
                const duration = audioBuffer.duration;
                const width = timelineCanvas.width;
                tlCtx.clearRect(0, 0, width, 30);
                tlCtx.fillStyle = '#9ca3af'; // gray-400
                tlCtx.font = '10px Inter';

                const pixelsPerSecond = (audioBuffer.length * zoom) / duration;
                
                // Determine major and minor tick intervals based on zoom
                const timeIntervals = [0.01, 0.05, 0.1, 0.25, 0.5, 1, 2, 5, 10, 15, 30, 60];
                let majorTickInterval = timeIntervals.find(interval => interval * pixelsPerSecond > 80) || 60;
                let minorTickInterval = majorTickInterval / 5;
                
                for (let time = 0; time <= duration; time += minorTickInterval) {
                    const x = time * pixelsPerSecond;
                    
                    if (time % majorTickInterval < 0.001) { // Major tick
                        tlCtx.fillRect(x, 15, 1, 15);
                        tlCtx.textAlign = "center";
                        tlCtx.fillText(formatTime(time), x, 12);
                    } else { // Minor tick
                        tlCtx.fillRect(x, 20, 1, 10);
                    }
                }
            }

            function drawPlayhead() {
                if (!audioContext) return;
                
                const currentTime = (audioContext.currentTime - startTime) + startOffset;
                const x = (currentTime * audioBuffer.sampleRate) * zoom;
                
                if (x >= 0 && x <= waveformCanvas.width) {
                    // Draw on waveform
                    wfCtx.fillStyle = '#f87171'; // red-400
                    wfCtx.fillRect(x, 0, 1, waveformCanvas.height);
                    
                    // Draw on timeline
                    tlCtx.fillStyle = '#f87171';
                    tlCtx.fillRect(x, 0, 1, timelineCanvas.height);
                }
            }

            function drawSelection() {
                if (selectionStartSample === null || selectionEndSample === null) return;
                
                const startX = Math.min(selectionStartSample, selectionEndSample) * zoom;
                const width = Math.abs(selectionEndSample - selectionStartSample) * zoom;
                
                wfCtx.fillStyle = 'rgba(59, 130, 246, 0.3)'; // blue-500 with alpha
                wfCtx.fillRect(startX, 0, width, waveformCanvas.height);
            }

            // --- Playback ---
            function playPlayback() {
                if (isPlaying) return;
                initAudioContext();
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(audioContext.destination);

                let offset = startOffset;
                let duration;

                if (selectionStartSample !== null) {
                    const selStart = Math.min(selectionStartSample, selectionEndSample);
                    const selEnd = Math.max(selectionStartSample, selectionEndSample);
                    offset = selStart / audioBuffer.sampleRate;
                    duration = (selEnd - selStart) / audioBuffer.sampleRate;
                    startOffset = offset;
                }
                
                if (isLooping) {
                   sourceNode.loop = true;
                   if(selectionStartSample !== null) {
                       sourceNode.loopStart = offset;
                       sourceNode.loopEnd = offset + duration;
                   }
                }

                sourceNode.start(0, offset, duration);
                
                startTime = audioContext.currentTime;
                isPlaying = true;
                playBtn.innerHTML = `<i data-lucide="pause" class="w-5 h-5"></i>`;
                lucide.createIcons();
                
                sourceNode.onended = () => {
                    if (isPlaying) {
                        stopPlayback();
                    }
                };
                
                animationLoop();
            }

            function pausePlayback() {
                if (!isPlaying) return;
                cancelAnimationFrame(animationFrameId);
                sourceNode.stop();
                sourceNode = null;
                startOffset += audioContext.currentTime - startTime;
                isPlaying = false;
                playBtn.innerHTML = `<i data-lucide="play" class="w-5 h-5"></i>`;
                lucide.createIcons();
            }

            function stopPlayback() {
                if (sourceNode) {
                    sourceNode.stop();
                    sourceNode = null;
                }
                cancelAnimationFrame(animationFrameId);
                startOffset = 0;
                if(selectionStartSample !== null) {
                    startOffset = Math.min(selectionStartSample, selectionEndSample) / audioBuffer.sampleRate;
                }
                isPlaying = false;
                playBtn.innerHTML = `<i data-lucide="play" class="w-5 h-5"></i>`;
                lucide.createIcons();
                draw(); // Redraw to reset playhead
            }

            function animationLoop() {
                if (isPlaying) {
                    draw();
                    animationFrameId = requestAnimationFrame(animationLoop);
                    let currentPlaybackTime = startOffset + (audioContext.currentTime - startTime);
                    if(isLooping && selectionStartSample !== null) {
                        const selStart = Math.min(selectionStartSample, selectionEndSample) / audioBuffer.sampleRate;
                        const selEnd = Math.max(selectionStartSample, selectionEndSample) / audioBuffer.sampleRate;
                        if (currentPlaybackTime >= selEnd) {
                            startOffset = selStart;
                            startTime = audioContext.currentTime;
                        }
                    }
                }
            }

            playBtn.addEventListener('click', () => {
                if (isPlaying) {
                    pausePlayback();
                } else {
                    playPlayback();
                }
            });

            stopBtn.addEventListener('click', stopPlayback);

            loopBtn.addEventListener('click', () => {
                isLooping = !isLooping;
                loopBtn.dataset.active = isLooping;
                if(isPlaying) {
                    stopPlayback();
                    playPlayback();
                }
            });

            // --- Editing ---
            function getSelectedRegion() {
                if (selectionStartSample === null || selectionEndSample === null) return null;
                const start = Math.min(selectionStartSample, selectionEndSample);
                const end = Math.max(selectionStartSample, selectionEndSample);
                return { start, end };
            }

            cutBtn.addEventListener('click', () => {
                const region = getSelectedRegion();
                if (!region) return;

                copyBtn.click(); // Copy first
                deleteBtn.click(); // Then delete
            });

            copyBtn.addEventListener('click', () => {
                const region = getSelectedRegion();
                if (!region) return;

                const length = region.end - region.start;
                clipboardBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    length,
                    audioBuffer.sampleRate
                );
                
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const from = audioBuffer.getChannelData(i).subarray(region.start, region.end);
                    clipboardBuffer.copyToChannel(from, i);
                }
                updateButtonStates();
            });

            pasteBtn.addEventListener('click', () => {
                if (!clipboardBuffer) return;

                const cursorSample = Math.round((startOffset * audioBuffer.sampleRate));
                const oldLength = audioBuffer.length;
                const newLength = oldLength + clipboardBuffer.length;
                
                const newBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    newLength,
                    audioBuffer.sampleRate
                );

                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const oldData = audioBuffer.getChannelData(i);
                    const newData = newBuffer.getChannelData(i);
                    const pasteData = clipboardBuffer.getChannelData(i);

                    newData.set(oldData.subarray(0, cursorSample), 0);
                    newData.set(pasteData, cursorSample);
                    newData.set(oldData.subarray(cursorSample), cursorSample + clipboardBuffer.length);
                }
                audioBuffer = newBuffer;
                clearSelection();
                draw();
                updateStatusBar();
            });

            deleteBtn.addEventListener('click', () => {
                const region = getSelectedRegion();
                if (!region) return;

                const oldLength = audioBuffer.length;
                const selectionLength = region.end - region.start;
                const newLength = oldLength - selectionLength;

                if (newLength === 0) {
                    audioBuffer = null;
                    placeholder.style.display = 'flex';
                    resetState();
                    updateButtonStates();
                    wfCtx.clearRect(0,0,waveformCanvas.width,waveformCanvas.height);
                    tlCtx.clearRect(0,0,timelineCanvas.width,timelineCanvas.height);
                    updateStatusBar();
                    return;
                }

                const newBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    newLength,
                    audioBuffer.sampleRate
                );

                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const oldData = audioBuffer.getChannelData(i);
                    const newData = newBuffer.getChannelData(i);

                    newData.set(oldData.subarray(0, region.start), 0);
                    newData.set(oldData.subarray(region.end), region.start);
                }
                audioBuffer = newBuffer;
                clearSelection();
                draw();
                updateStatusBar();
            });
            
            trimBtn.addEventListener('click', () => {
                const region = getSelectedRegion();
                if (!region) return;

                const length = region.end - region.start;
                const newBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    length,
                    audioBuffer.sampleRate
                );
                
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const from = audioBuffer.getChannelData(i).subarray(region.start, region.end);
                    newBuffer.copyToChannel(from, i);
                }
                audioBuffer = newBuffer;
                clearSelection();
                draw();
                updateStatusBar();
            });

            // --- Zooming ---
            zoomInBtn.addEventListener('click', () => {
                zoom *= 1.5;
                draw();
            });
            
            zoomOutBtn.addEventListener('click', () => {
                zoom /= 1.5;
                draw();
            });

            // --- Mouse / Selection ---
            function getSampleFromX(x) {
                return Math.round(x / zoom);
            }

            function handleInteractionStart(e) {
                if (!audioBuffer) return;
                isDragging = true;
                const rect = waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left + waveformCanvas.parentElement.scrollLeft;
                selectionStartSample = getSampleFromX(x);
                selectionEndSample = selectionStartSample;

                // Move playhead to click position
                startOffset = selectionStartSample / audioBuffer.sampleRate;
                if(isPlaying) stopPlayback();
                else draw();

                updateSelectionStatus();
            }

            function handleInteractionMove(e) {
                if (!isDragging || !audioBuffer) return;
                const rect = waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left + waveformCanvas.parentElement.scrollLeft;
                selectionEndSample = getSampleFromX(x);
                draw();
                updateSelectionStatus();
            }

            function handleInteractionEnd(e) {
                isDragging = false;
                if(selectionStartSample === selectionEndSample) {
                   clearSelection();
                }
                updateButtonStates();
            }
            
            waveformCanvas.addEventListener('mousedown', handleInteractionStart);
            window.addEventListener('mousemove', handleInteractionMove);
            window.addEventListener('mouseup', handleInteractionEnd);
            
            function clearSelection() {
                selectionStartSample = null;
                selectionEndSample = null;
                updateButtonStates();
                updateSelectionStatus();
                draw();
            }

            // --- UI Updates ---
            function updateStatusBar() {
                if (audioBuffer) {
                    durationEl.textContent = formatTime(audioBuffer.duration);
                    sampleRateEl.textContent = `${audioBuffer.sampleRate} Hz`;
                } else {
                    durationEl.textContent = '00:00.000';
                    sampleRateEl.textContent = 'N/A';
                }
            }

            function updateSelectionStatus() {
                if (selectionStartSample !== null && selectionEndSample !== null) {
                    const start = Math.min(selectionStartSample, selectionEndSample);
                    const end = Math.max(selectionStartSample, selectionEndSample);
                    const startTime = start / audioBuffer.sampleRate;
                    const endTime = end / audioBuffer.sampleRate;
                    
                    selectionStartEl.textContent = formatTime(startTime);
                    selectionEndEl.textContent = formatTime(endTime);
                    selectionLengthEl.textContent = formatTime(endTime - startTime);
                } else {
                    selectionStartEl.textContent = '00:00.000';
                    selectionEndEl.textContent = '00:00.000';
                    selectionLengthEl.textContent = '00:00.000';
                }
            }

            function formatTime(seconds) {
                const min = Math.floor(seconds / 60);
                const sec = Math.floor(seconds % 60);
                const ms = Math.floor((seconds * 1000) % 1000);
                return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
            }

            // --- Keyboard Shortcuts ---
            window.addEventListener('keydown', (e) => {
                if (!audioBuffer) return;
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    playBtn.click();
                } else if (e.code === 'Escape') {
                    e.preventDefault();
                    stopBtn.click();
                } else if (e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    loopBtn.click();
                } else if (e.key === '+' || e.key === '=') {
                    e.preventDefault();
                    zoomInBtn.click();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOutBtn.click();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    deleteBtn.click();
                }

                if (e.ctrlKey || e.metaKey) { // Meta for Mac
                    switch (e.key.toLowerCase()) {
                        case 'x': e.preventDefault(); cutBtn.click(); break;
                        case 'c': e.preventDefault(); copyBtn.click(); break;
                        case 'v': e.preventDefault(); pasteBtn.click(); break;
                        case 'a': // Select all
                            e.preventDefault();
                            selectionStartSample = 0;
                            selectionEndSample = audioBuffer.length;
                            updateSelectionStatus();
                            updateButtonStates();
                            draw();
                            break;
                    }
                }
            });

            // --- Window Resize ---
            window.addEventListener('resize', () => {
                if (audioBuffer) {
                    draw();
                }
            });
        });
    </script>
</body>
</html>
